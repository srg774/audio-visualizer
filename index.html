<script>
    // The 'tracks' array that the player actively uses. It will be populated by refreshTrackList.
    let tracks = []; // Start with an empty array

    let currentTrackIndex = 0; // Will be set to a random track after initial load
    let isPlaying = false;
    let hasUserInitiatedPlayback = false; // Flag to track if user has initiated playback at least once

    // Get references to HTML elements
    const audio = document.getElementById('audio');
    const currentTrackDisplay = document.getElementById('current-track-display');
    const playPauseButton = document.getElementById('play-pause-button');
    const prevButton = document.getElementById('prev-button');
    const nextButton = document.getElementById('next-button');
    const seekBar = document.getElementById('seek-bar');
    const seekBarProgress = document.getElementById('seek-bar-progress');
    const seekBarThumb = document.getElementById('seek-bar-thumb');
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');

    // New element references for the refresh feature and status messages
    const refreshTracksButton = document.getElementById('refresh-tracks-button');
    const statusMessageDiv = document.getElementById('status-message');

    // Setup Web Audio API for visualizer and compressor
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const analyser = audioContext.createAnalyser();
    const compressor = audioContext.createDynamicsCompressor(); // Dynamics Compressor for "auto-max" effect

    let source; // Audio source node, connected after user gesture
    let audioSourceConnected = false; // Flag to track if the audio source has been connected

    // Function to ensure the AudioContext is running and source is connected
    function ensureAudioContextAndSource() {
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                console.log('AudioContext resumed!');
                if (!audioSourceConnected) {
                    source = audioContext.createMediaElementSource(audio);
                    source.connect(compressor); // Source connects to compressor
                    compressor.connect(analyser); // Compressor connects to analyser
                    analyser.connect(audioContext.destination); // Analyser connects to speakers
                    audioSourceConnected = true;
                }
            }).catch(e => console.error("Error resuming AudioContext:", e));
        } else {
            if (!audioSourceConnected) {
                source = audioContext.createMediaElementSource(audio);
                source.connect(compressor); // Source connects to compressor
                compressor.connect(analyser); // Compressor connects to analyser
                analyser.connect(audioContext.destination); // Analyser connects to speakers
                audioSourceConnected = true;
            }
        }
    }

    // Analyser settings for the visualizer
    analyser.fftSize = 256;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    // Resize canvas to match its displayed size for proper rendering
    function resizeCanvas() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
    }

    /**
     * Controls the shimmer effect on the track title.
     * @param {boolean} isActive - True to activate shimmer, false to deactivate.
     */
    // --- START OF MODIFIED CODE BLOCK ---
    function setShimmerState(isActive) {
        // We are disabling the shimmer effect, so we always treat the state as inactive.
        let trackTitleText = tracks[currentTrackIndex]?.title || "";
        currentTrackDisplay.innerHTML = ''; // Clear content first

        // Always use the non-shimmer logic to display the title.
        currentTrackDisplay.textContent = trackTitleText;
        // Check if the 'isNew' tag should be added
        if (tracks[currentTrackIndex]?.isNew) {
            currentTrackDisplay.innerHTML += `<span class="rainbow-new">NEW</span>`;
        }
        // Always ensure the shimmer-active class is removed
        currentTrackDisplay.classList.remove('shimmer-active');
    }
    // --- END OF MODIFIED CODE BLOCK ---

    // SVG icons for play and pause
    const playIconSVG = `
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
        </svg>
    `;
    const pauseIconSVG = `
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="6" y="4" width="4" height="16"></rect>
            <rect x="14" y="4" width="4" height="16"></rect>
        </svg>
    `;

    /**
     * Loads a track and optionally attempts to auto-play it.
     * @param {number} index - The index of the track to load.
     * @param {boolean} shouldAutoPlay - Whether the track should attempt to auto-play.
     */
    function loadTrack(index, shouldAutoPlay = false) {
        if (tracks.length === 0) {
            console.warn("No tracks available to load.");
            currentTrackDisplay.textContent = "No tracks loaded.";
            playPauseButton.innerHTML = playIconSVG;
            return;
        }

        // Ensure index is within bounds of the tracks array length
        if (index >= tracks.length || index < 0) {
            index = 0; // Default to first track if out of bounds
        }
        currentTrackIndex = index; // Update the global index

        const track = tracks[currentTrackIndex];
        audio.src = track.src; // Set the audio source

        setShimmerState(false); // Always set initial state to false (no shimmer) on load

        updateMediaSession(); // Update browser's media session info

        if (shouldAutoPlay && hasUserInitiatedPlayback) {
            ensureAudioContextAndSource();
            audio.play().then(() => {
                isPlaying = true;
                playPauseButton.innerHTML = pauseIconSVG; // Set to pause icon
                drawVisualizer(); // Start visualizer
                // The shimmer effect is now permanently disabled via the setShimmerState function.
                // setShimmerState(true); // OLD: This line is no longer necessary as the function is modified
                trackPlayed(track.title); // Track play only on successful play
            }).catch(error => {
                console.warn("Autoplay prevented:", error);
                isPlaying = false;
                playPauseButton.innerHTML = playIconSVG; // Set to play icon if autoplay fails
                // setShimmerState(false); // OLD: No longer needed
            });
        } else {
            isPlaying = false;
            audio.pause();
            playPauseButton.innerHTML = playIconSVG; // Always show play icon if not playing
            // Reset seek bar visuals for new track load
            seekBarProgress.style.width = '0%';
            seekBarThumb.style.left = '0px';
            // setShimmerState(false); // OLD: No longer needed, handled at the start of the function
        }
    }

    // Toggle Play/Pause functionality
    function togglePlayback() {
        if (!audioSourceConnected) {
            ensureAudioContextAndSource(); // Connect nodes if not already connected
        }

        if (audio.paused) {
            audio.play().then(() => {
                isPlaying = true;
                playPauseButton.innerHTML = pauseIconSVG; // Change to pause icon
                drawVisualizer();
                hasUserInitiatedPlayback = true; // Set this flag on the very first successful play
                // setShimmerState(true); // OLD: No longer needed
                trackPlayed(tracks[currentTrackIndex]?.title); // Track play
            }).catch(error => {
                console.warn("Playback prevented (likely no user gesture yet):", error);
                isPlaying = false;
                playPauseButton.innerHTML = playIconSVG; // Change back to play icon
                // setShimmerState(false); // OLD: No longer needed
            });
        } else {
            audio.pause();
            isPlaying = false;
            playPauseButton.innerHTML = playIconSVG; // Change to play icon
            // setShimmerState(false); // OLD: No longer needed
        }
    }

    // Event listeners for player controls
    playPauseButton.addEventListener('click', togglePlayback);

    prevButton.addEventListener('click', () => {
        currentTrackIndex = (currentTrackIndex - 1 + tracks.length) % tracks.length;
        loadTrack(currentTrackIndex, hasUserInitiatedPlayback);
    });

    nextButton.addEventListener('click', () => {
        currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
        loadTrack(currentTrackIndex, hasUserInitiatedPlayback);
    });

    // Seek Bar Logic: Listen for metadata to ensure duration is known, then update time
    audio.addEventListener('loadedmetadata', () => {
        if (!isNaN(audio.duration)) {
            seekBarProgress.style.width = '0%';
            const thumbPos = 0;
            seekBarThumb.style.left = `${thumbPos}px`;
        }
    });

    audio.addEventListener('timeupdate', () => {
        if (!isNaN(audio.duration)) {
            const progress = (audio.currentTime / audio.duration) * 100;
            seekBarProgress.style.width = `${progress}%`;
            const thumbWidth = seekBarThumb.offsetWidth;
            const seekBarWidth = seekBar.offsetWidth;
            const thumbPos = (progress / 100) * seekBarWidth;
            const adjustedThumbPos = Math.max(0, Math.min(seekBarWidth - thumbWidth / 2, thumbPos - (thumbWidth / 2)));
            seekBarThumb.style.left = `${adjustedThumbPos}px`;
        }
    });

    seekBar.addEventListener('click', (e) => {
        if (isNaN(audio.duration)) return;

        const rect = seekBar.getBoundingClientRect();
        const seekTime = ((e.clientX - rect.left) / rect.width) * audio.duration;
        audio.currentTime = seekTime;
        if (isPlaying || hasUserInitiatedPlayback) {
            ensureAudioContextAndSource();
            audio.play().catch(error => console.warn("Seek-and-play prevented:", error));
        }
    });

    // Visualizer drawing function
    function drawVisualizer() {
        if (audioContext.state === 'running' && !audio.paused) {
            requestAnimationFrame(drawVisualizer);
            analyser.getByteFrequencyData(dataArray);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.6;

            for (let i = 0; i < bufferLength; i++) {
                const angle = (i / bufferLength) * 2 * Math.PI;
                const barHeight = (dataArray[i] / 255) * radius * 0.8;
                const x1 = centerX + Math.cos(angle) * radius;
                const y1 = centerY + Math.sin(angle) * radius;
                const x2 = centerX + Math.cos(angle) * (radius + barHeight);
                const y2 = centerY + Math.sin(angle) * (radius + barHeight);

                ctx.strokeStyle = `rgb(${dataArray[i]}, 50, 200)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }
    }

    // GoatCounter Analytics tracking for track plays
    function trackPlayed(trackTitle) {
        if (window.goatcounter && hasUserInitiatedPlayback) {
            goatcounter.count({
                path: `/track/${encodeURIComponent(trackTitle)}`,
                title: `Track Played: ${trackTitle}`
            });
        }
    }

    // Event listener for when audio finishes
    audio.addEventListener('ended', () => {
        setShimmerState(false); // Stop shimmer when track ends
        currentTrackIndex = (currentTrackIndex + 1) % tracks.length;
        loadTrack(currentTrackIndex, hasUserInitiatedPlayback);
    });

    // Update Media Session (for Lock Screen controls)
    function updateMediaSession() {
        if ('mediaSession' in navigator) {
            const track = tracks[currentTrackIndex];
            if (track) { // Ensure track exists before setting metadata
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: track.title,
                    artist: 'SRG774',
                    album: 'My Playlist',
                    artwork: [
                        { src: 'assets/android-chrome-512x512.png', sizes: '512x512', type: 'image/png' }
                    ]
                });

                navigator.mediaSession.setActionHandler('play', () => { togglePlayback(); });
                navigator.mediaSession.setActionHandler('pause', hasUserInitiatedPlayback ? () => { togglePlayback(); } : null);
                navigator.mediaSession.setActionHandler('previoustrack', () => { prevButton.click(); });
                navigator.mediaSession.setActionHandler('nexttrack', () => { nextButton.click(); });
            }
        }
    }

    // --- FUNCTIONS FOR TRACK REFRESH ---

    // Function to display temporary status messages
    function showStatusMessage(message, duration = 3000) {
        statusMessageDiv.textContent = message;
        statusMessageDiv.classList.add('show');
        if (statusMessageDiv.timeoutId) {
            clearTimeout(statusMessageDiv.timeoutId);
        }
        statusMessageDiv.timeoutId = setTimeout(() => {
            statusMessageDiv.classList.remove('show');
            statusMessageDiv.timeoutId = null;
        }, duration);
    }

    /**
     * Compares two track lists for differences.
     * Checks for changes in length, title, src, and isNew status.
     * @param {Array<Object>} oldList - The existing list of tracks.
     * @param {Array<Object>} newList - The new list of tracks.
     * @returns {boolean} True if lists are different (length, or title/src/isNew mismatch), false otherwise.
     */
    function haveTracksChanged(oldList, newList) {
        if (oldList.length !== newList.length) {
            return true; // Different number of tracks
        }
        for (let i = 0; i < oldList.length; i++) {
            // Compare title, source, and isNew status
            if (oldList[i].title !== newList[i].title ||
                oldList[i].src !== newList[i].src ||
                !!oldList[i].isNew !== !!newList[i].isNew) { // Ensure boolean comparison for isNew
                return true; // Track details changed
            }
        }
        return false; // No changes detected
    }

    // Function to refresh the track list from the external 'tracks.json' file
    async function refreshTrackList() {
        showStatusMessage("Checking for new tracks...", 1500); // Give immediate feedback
        try {
            // Fetch tracks.json from the network (service worker will handle caching/freshness)
            const response = await fetch('tracks.json');
            if (!response.ok) {
                throw new Error(`Failed to fetch track list: ${response.status} ${response.statusText}`);
            }
            const newTracks = await response.json();

            if (haveTracksChanged(tracks, newTracks)) {
                const oldLength = tracks.length;
                tracks = newTracks; // Update the active tracks array

                let message = "";
                if (tracks.length > oldLength) {
                    message = "New tracks added!";
                } else if (tracks.length < oldLength) {
                    message = "Tracks removed.";
                } else {
                    message = "Track list updated!"; // For metadata changes etc.
                }
                showStatusMessage(message, 3000);

                // If the currently playing track's index is now out of bounds
                // or the track itself has changed, load the (possibly new) current track.
                if (currentTrackIndex >= tracks.length || (tracks.length > 0 && tracks[currentTrackIndex]?.src !== audio.src)) {
                    currentTrackIndex = 0; // Reset to first track if the list changed significantly
                }
                loadTrack(currentTrackIndex, isPlaying); // Attempt to continue playing
            } else {
                showStatusMessage("Track list is already up-to-date.", 2000);
            }
        } catch (error) {
            console.error("Error refreshing track list:", error);
            showStatusMessage("Failed to refresh tracks. Check your connection.", 3000);
        }
    }

    // Event listener for the refresh button
    refreshTracksButton.addEventListener('click', refreshTrackList);


    // Initial setup when the page loads
window.addEventListener('load', () => {
    resizeCanvas();
    // Load tracks initially from tracks.json
    refreshTrackList().then(() => {
        if (tracks.length > 0) {
            // Find the index of the first track marked as 'isNew'
            const newTrackIndex = tracks.findIndex(track => track.isNew);
            
            // If an 'isNew' track is found, use its index. Otherwise, default to the first track.
            if (newTrackIndex !== -1) {
                currentTrackIndex = newTrackIndex;
            } else {
                currentTrackIndex = 0;
            }
            
            loadTrack(currentTrackIndex, false); // Do not auto-play on initial load
        } else {
            showStatusMessage("No music tracks found! Please add them to tracks.json.", 5000);
        }
    }).catch(error => {
        console.error("Initial track loading failed:", error);
        showStatusMessage("Failed to load tracks initially. Try refreshing.", 5000);
    });
});

    window.addEventListener('resize', resizeCanvas);
</script>
